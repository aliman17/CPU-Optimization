n=16 
RDTSC instruction:
 187.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.070801 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 358.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.071960 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 218.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.112122 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 179.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.069519 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067871 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 381.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.154236 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 177.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067993 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 318.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.069580 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 180.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067932 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.069641 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 186.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.071472 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 179.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.068176 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.076782 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 179.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.136902 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 228.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.075256 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 178.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067993 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 179.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.070618 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 307.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.083130 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 196.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.075256 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067993 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.068909 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067932 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 177.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.071960 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 179.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067932 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.069824 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067993 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 186.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.071533 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 217.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.078735 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.067993 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=16 
RDTSC instruction:
 176.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.069824 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 372.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.143921 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 388.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.137207 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 420.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.145569 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 441.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.147827 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 501.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.171631 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 415.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.149536 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 372.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.137268 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 374.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.148560 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 382.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.142334 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 406.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.218140 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 423.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.238953 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 394.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.143005 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 390.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.163269 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 378.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.144714 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 416.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.138367 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 374.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.146973 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 2010.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.144287 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=32 
RDTSC instruction:
 419.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.158203 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 377.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.140564 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 414.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.146484 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 850.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.180237 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 393.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.144348 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 369.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.137634 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 369.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.249023 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 403.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.141296 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 369.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.141785 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 394.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.150635 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 596.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.141968 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 372.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.143860 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=32 
RDTSC instruction:
 371.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.142151 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 722.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.278870 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 721.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.377625 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 718.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.346558 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 922.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.277527 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 716.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.285889 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 717.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.295715 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 724.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.277893 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 970.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.323181 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 719.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.302246 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 723.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.277649 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 748.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.286499 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 1088.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.315186 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 2154.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.276794 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 729.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.304993 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=64 
RDTSC instruction:
 1605.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.360596 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 1138.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.448547 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 727.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.286011 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 715.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.277100 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 720.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.331482 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 726.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.280334 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 812.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.277527 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 848.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.278931 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 726.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.296387 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 718.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.288452 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 717.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.276855 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 718.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.331055 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 753.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.277649 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 774.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.278015 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 719.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.297668 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000000 seconds measured

n=64 
RDTSC instruction:
 758.000000 cycles measured => 0.000000 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.286743 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000000 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1970.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.725220 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1436.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.553528 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1407.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.542725 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1393.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.546021 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1399.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.553772 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1441.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.543091 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1418.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.742065 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1442.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.553467 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1422.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.557312 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1466.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.557129 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 3110.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.567505 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1933.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.576355 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1671.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.546875 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1423.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.543274 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1449.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.708496 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1417.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.549255 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1415.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.544739 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1584.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.575439 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1404.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.556091 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1432.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.696655 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 3502.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.622620 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 2198.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.552185 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1450.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.560364 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1406.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.544006 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1419.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.542969 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1405.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.569092 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1755.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.554504 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1410.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.540283 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1567.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.547119 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=128 
RDTSC instruction:
 1413.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 0.546814 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 6181.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.260193 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2820.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.063293 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3101.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.225037 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2843.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.207581 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3006.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.071289 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 5757.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.251526 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2893.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.086975 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2989.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.118835 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2828.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.071350 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2854.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.073608 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2870.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.138245 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2859.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.075684 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3297.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.199463 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2790.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.080811 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3535.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.124023 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2879.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.112915 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3315.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.215881 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2800.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.076538 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2811.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.303467 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2795.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.079529 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2806.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.090637 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3387.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.065002 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2835.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.075256 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3264.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.068054 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2805.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.256958 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2785.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.089966 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3918.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.075623 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2993.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.076782 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 3134.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.202393 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=256 
RDTSC instruction:
 2772.000000 cycles measured => 0.000001 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 1.141968 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000001 seconds. 

C gettimeofday() function:
 0.000001 seconds measured

n=512 
RDTSC instruction:
 6484.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.779114 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000003 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6369.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.490723 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6743.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.338989 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000004 seconds measured

n=512 
RDTSC instruction:
 6245.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.480408 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6511.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.305359 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 8745.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.472961 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6587.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.476562 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6470.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.496033 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000003 seconds measured

n=512 
RDTSC instruction:
 6611.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.286499 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000003 seconds measured

n=512 
RDTSC instruction:
 6041.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.313965 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 12180.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.582886 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000003 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6274.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.301392 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6922.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.338074 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6257.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.586670 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000003 seconds. 

C gettimeofday() function:
 0.000003 seconds measured

n=512 
RDTSC instruction:
 6396.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.290955 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000004 seconds measured

n=512 
RDTSC instruction:
 7174.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.464600 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 7782.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.313171 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6592.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.324219 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6182.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.287842 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 5979.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.466492 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6091.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 3.207947 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000003 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6736.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.340515 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6162.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.381287 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 5955.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.417114 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6527.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.372620 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6112.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.412659 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000003 seconds measured

n=512 
RDTSC instruction:
 6562.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.425354 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 7037.000000 cycles measured => 0.000003 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.382751 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000002 seconds measured

n=512 
RDTSC instruction:
 6092.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.552856 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000003 seconds. 

C gettimeofday() function:
 0.000003 seconds measured

n=512 
RDTSC instruction:
 6350.000000 cycles measured => 0.000002 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 2.290283 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000002 seconds. 

C gettimeofday() function:
 0.000003 seconds measured

n=1024 
RDTSC instruction:
 14234.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.800415 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12484.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.684753 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12561.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.679321 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13309.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.653442 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12471.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.806152 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12405.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.838379 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 14051.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.814575 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12614.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.794312 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12089.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.815796 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13238.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.768433 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13477.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.806763 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000006 seconds measured

n=1024 
RDTSC instruction:
 12998.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.788208 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12165.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.043213 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13460.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.800659 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12183.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.843506 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13296.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.683350 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12205.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.680054 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13664.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.992371 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 14987.000000 cycles measured => 0.000006 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.932739 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12661.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.786621 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000006 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13572.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.099731 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 14067.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.932495 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13560.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.748291 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000006 seconds measured

n=1024 
RDTSC instruction:
 36559.000000 cycles measured => 0.000014 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.683228 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000012 seconds measured

n=1024 
RDTSC instruction:
 40617.000000 cycles measured => 0.000016 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.902832 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000006 seconds. 

C gettimeofday() function:
 0.000008 seconds measured

n=1024 
RDTSC instruction:
 14648.000000 cycles measured => 0.000006 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.195801 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 15996.000000 cycles measured => 0.000006 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.829102 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 12020.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 4.782776 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13911.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.243286 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=1024 
RDTSC instruction:
 13839.000000 cycles measured => 0.000005 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 5.062134 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000005 seconds. 

C gettimeofday() function:
 0.000005 seconds measured

n=2048 
RDTSC instruction:
 25420.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.502686 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 28315.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.402222 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000016 seconds measured

n=2048 
RDTSC instruction:
 27742.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.291748 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 26375.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.653076 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000011 seconds. 

C gettimeofday() function:
 0.000019 seconds measured

n=2048 
RDTSC instruction:
 28259.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.141113 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 25733.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.905762 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 24804.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.423950 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 26117.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.962158 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000011 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 29643.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.680664 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000013 seconds measured

n=2048 
RDTSC instruction:
 27593.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.481934 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 24973.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 11.769043 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000012 seconds. 

C gettimeofday() function:
 0.000009 seconds measured

n=2048 
RDTSC instruction:
 24632.000000 cycles measured => 0.000009 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.450439 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000015 seconds measured

n=2048 
RDTSC instruction:
 24937.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.399658 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000009 seconds measured

n=2048 
RDTSC instruction:
 25699.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.616455 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000011 seconds. 

C gettimeofday() function:
 0.000009 seconds measured

n=2048 
RDTSC instruction:
 25644.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.346191 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000014 seconds measured

n=2048 
RDTSC instruction:
 24437.000000 cycles measured => 0.000009 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.156494 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000009 seconds measured

n=2048 
RDTSC instruction:
 31690.000000 cycles measured => 0.000012 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.703125 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 27253.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 11.911377 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000012 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 27238.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.306396 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000012 seconds measured

n=2048 
RDTSC instruction:
 24542.000000 cycles measured => 0.000009 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.086670 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 43161.000000 cycles measured => 0.000017 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.489258 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 25439.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.091064 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 29326.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.359863 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000009 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 25845.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.586182 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 25673.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.707764 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000012 seconds measured

n=2048 
RDTSC instruction:
 68850.000000 cycles measured => 0.000026 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 12.195557 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000012 seconds. 

C gettimeofday() function:
 0.000013 seconds measured

n=2048 
RDTSC instruction:
 30585.000000 cycles measured => 0.000012 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 10.816406 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000011 seconds. 

C gettimeofday() function:
 0.000015 seconds measured

n=2048 
RDTSC instruction:
 60417.000000 cycles measured => 0.000023 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.878662 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000011 seconds measured

n=2048 
RDTSC instruction:
 25946.000000 cycles measured => 0.000010 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 11.540283 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000012 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=2048 
RDTSC instruction:
 27612.000000 cycles measured => 0.000011 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 9.550049 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000010 seconds. 

C gettimeofday() function:
 0.000010 seconds measured

n=4096 
RDTSC instruction:
 53132.000000 cycles measured => 0.000020 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.683105 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000022 seconds measured

n=4096 
RDTSC instruction:
 49038.000000 cycles measured => 0.000019 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 21.712402 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000022 seconds. 

C gettimeofday() function:
 0.000031 seconds measured

n=4096 
RDTSC instruction:
 52057.000000 cycles measured => 0.000020 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 18.715820 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000019 seconds measured

n=4096 
RDTSC instruction:
 85817.000000 cycles measured => 0.000033 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.817383 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000021 seconds. 

C gettimeofday() function:
 0.000021 seconds measured

n=4096 
RDTSC instruction:
 53704.000000 cycles measured => 0.000021 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 21.800293 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000022 seconds. 

C gettimeofday() function:
 0.000027 seconds measured

n=4096 
RDTSC instruction:
 95007.000000 cycles measured => 0.000037 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.773926 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000021 seconds. 

C gettimeofday() function:
 0.000023 seconds measured

n=4096 
RDTSC instruction:
 82196.000000 cycles measured => 0.000032 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.788574 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000028 seconds measured

n=4096 
RDTSC instruction:
 58301.000000 cycles measured => 0.000022 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.567871 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 80606.000000 cycles measured => 0.000031 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.877441 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 74503.000000 cycles measured => 0.000029 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.795410 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000021 seconds measured

n=4096 
RDTSC instruction:
 53095.000000 cycles measured => 0.000020 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.954102 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000021 seconds. 

C gettimeofday() function:
 0.000022 seconds measured

n=4096 
RDTSC instruction:
 54864.000000 cycles measured => 0.000021 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.492676 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000028 seconds measured

n=4096 
RDTSC instruction:
 49509.000000 cycles measured => 0.000019 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.320801 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000019 seconds measured

n=4096 
RDTSC instruction:
 54425.000000 cycles measured => 0.000021 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.673340 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000021 seconds. 

C gettimeofday() function:
 0.000032 seconds measured

n=4096 
RDTSC instruction:
 51059.000000 cycles measured => 0.000020 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 18.963379 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 58443.000000 cycles measured => 0.000022 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.798340 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000021 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 49616.000000 cycles measured => 0.000019 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.071289 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000019 seconds measured

n=4096 
RDTSC instruction:
 57315.000000 cycles measured => 0.000022 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 18.931641 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000022 seconds measured

n=4096 
RDTSC instruction:
 50325.000000 cycles measured => 0.000019 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 19.679688 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000021 seconds measured

n=4096 
RDTSC instruction:
 53952.000000 cycles measured => 0.000021 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 22.772461 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000023 seconds. 

C gettimeofday() function:
 0.000019 seconds measured

n=4096 
RDTSC instruction:
 76458.000000 cycles measured => 0.000029 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 20.035156 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000020 seconds. 

C gettimeofday() function:
 0.000022 seconds measured

n=4096 
RDTSC instruction:
 58902.000000 cycles measured => 0.000023 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 21.098145 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000021 seconds. 

C gettimeofday() function:
 0.000021 seconds measured

n=4096 
RDTSC instruction:
 49414.000000 cycles measured => 0.000019 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 21.674316 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000022 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 54537.000000 cycles measured => 0.000021 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 18.864746 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 56448.000000 cycles measured => 0.000022 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 18.921875 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000019 seconds. 

C gettimeofday() function:
 0.000020 seconds measured

n=4096 
RDTSC instruction:
 67519.000000 cycles measured => 0.000026 seconds, assuming frequency is 2600.000000 MHz. (change in source file if different)

C clock() function:
 21.071777 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this val